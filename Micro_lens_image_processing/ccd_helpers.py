#### IMPORT MODULES ######
import os
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits import mplot3d
from skimage import morphology as morph
import lmfit
import math
from lmfit.models import GaussianModel
from lmfit.lineshapes import gaussian
from scipy.ndimage.filters import gaussian_filter
from scipy.ndimage.morphology import generate_binary_structure, binary_erosion
from scipy.ndimage.filters import maximum_filter
from PIL import Image, ImageOps

#### END IMPORT MODULES ######


### FILE STRUCTURE ######
# 1 Plotting Functions
# 2 Gaussian Functions
# 3 Image file handling Functions
# 4 Peak Detection and Blurring Functions
# 5 Calibration Functions
##########################



###### 1 PLOTING FUNCTIONS #########

# Surface plot
def tri_plot(X,Y,Z, title):
    """Plots a 3D map taking a gird of data using matplotlib's trisurf function

    Args:    
        X[numpy ndarry]: A flattened array of X values from -1, 1, formed from flattening x_grid 
        Y[numpy ndarry]: A flattened array of Y values from -1, 1, formed from flattening y_grid 
        Z[numpy ndarry]: A flattened array of Z values, formed from z_grid (intensity values from image data(
        title[string]: Name to assign to title of map

    Returns:
        A 3d map 

    """
    # Creating figure
    fig = plt.figure(figsize =(28, 18))
    ax = plt.axes(projection ='3d')

    # Creating plot
    ax.plot_trisurf(X, Y, Z, linewidth = 0.2, antialiased = True);
    ax.set_title(title)
    
    # show plot
    plt.show()

# 3D line and scatter plot
def line_sctr_3D(xtraj, ytraj, ztraj):

    """Plots a 3D map taking the x, y an z values generated by get_particle_traj.
        Makes both a line plot and overlayed with scattered points. Uses matplotlib's plot3D function. The
        set_(x)(y)(z)lim3d is set keep the map within perspective.

    Args:    
        xtraj[numpy arry]: A list of x float values ( generated via interpolate in get_paticle_traj)
        ytraj[numpy arry]: A list of y float values ( generated via interpolate in get_paticle_traj)
        ztraj[numpy arry]: A list of Z float values ( generated via gaussian1D_fit in get_paticle_traj)

    Returns:
        A 3d map with both lines and scatterd dots

    """
    
    # Crete the figure and the axes
    fig = plt.figure(figsize=(16,12))
    ax = plt.axes(projection="3d")

    # Define the x, y and z lines and plot
    z_line = ztraj
    x_line = xtraj
    y_line = ytraj
    ax.plot3D(x_line, y_line, z_line, 'green')

    # Define the points to plot
    z_points = ztraj
    x_points = xtraj
    y_points = ytraj
    ax.scatter3D(x_points, y_points, z_points, c=z_points, cmap='hsv');
    
    # Changed to represent the new data for Calibration
    ax.set_xlim3d([-0.9,0.9])
    ax.set_ylim3d([-0.6,0.6])
    ax.set_zlim3d([-6.25,-5.75])
    # Show the plot
    plt.show()

###### END PLOTING FUNCTIONS  #########


######## 2 GAUSSIAN FUNCTIONS #########

# Basic 2D gaussian function
def gaussian2d(x, y, a, cx, cy, bx, by):
    """Performs a gaussian 2D function

    Args:    
        x[float]: x corrdinate
        y[float]: y corrdinate
        a[float]: amplitude
        cx[float]: center x
        cy[float]: center y
        bx[float]: sigma x
        by[float]: sigma y

    Returns:
        The "z" point for our purposes 

    """
    z = a * np.exp(-(((x - cx)**2) / (2 * bx**2 )) - (((y - cy)**2) / (2 * by**2)))
    return z

# A 1D gaussian fitting function
def gaussian1D_fit(depth, coefs_a):
    
    """Returns the center ( our z) after performing a gaussian 1D fit. Checks first if the
         maximum amplitude is at the begining or end of the array ( which corresponds to the begining 
         or end of our depth) and if so, it will assign the particle without performing a fit.
         This function relies on the GaussianModel function from the lmfit library 
         to work. Make sure 'from lmfit.models import GaussianModel'
         is installed.

    Args:    
        depth[Python list / array]: An array of the depth from the CCD (-5.5, -5.4, ... -5.0)
        coefs_a[np array]: The array of amplitudes from get_particle_traj
    Returns:
        The zparticle 

    """
    # if max amplitude is last in coefs_a array return last of depth
    if np.max(coefs_a) == coefs_a[-1]:
        zparticle = depth[-1]
        return zparticle
    
    # if max amplitude is first of coefs_a array return first of depth
    elif np.max(coefs_a) == coefs_a[0]:
        zparticle = depth[0]
        return zparticle
    
    else:
        # get the values of depth and amplitude, set as np arrays just in case
        xval = np.array(depth)
        yval = np.array(coefs_a)

        # define the model to fit as the Gaussian Model
        model = GaussianModel()
        params = model.guess(yval, xval)

        # save the results
        result = model.fit(yval, params, x=xval)

        # save the coefficient values as a dict
        values = result.best_values

        # Save the z particle
        zparticle = values['center'] 

        return zparticle
    
    

    
# A sum of 2D gaussian functions   
def sum_2dgaussians(x, y, params):
    """
        Retruns the sum of 2D gaussians functions. Takes the result of get_peak_param
        as params
        
         Args:    
            x[numpy ndarray]: A 2D array of x_grid generated from image data (-1 ~ 1)
            y[numpy ndarray]: A 2D array of y_grid generated from image data (-1 ~ 1)
            params[numpy array]: A 1D array of the values of the peaks in the format a, cx, cy, bx, by
        
        Returns:
            The sum of multiple 2D gaussian functions 
    """
  
    # Get the number of parameters
    numParams = len(params)
    # Divde by 5 as we should be getting a repeating pattern of a, cx, cy, bx, by
    numGaussians = numParams / 5
    # Keep track of the number of Peaks to fit Gaussians to
    numGaussians = int(numGaussians)

    # Assign a, cx and cy, bx and by
    l = len(params)
    amp = params[0:l:5]
    center_x = params[1:l:5]
    center_y = params[2:l:5]
    bx = params[3:l:5]
    by = params[4:l:5]
    
    # Because lmfit uses differnt 2D gauss function
    #amp2 = amp / (bx*by*2*math.pi)
    
    # initlize an array of zeros that matches the shape of x_grid
        # This is so we have something to add the result of the gaussian funciton to
    z = np.zeros(x.shape)
    for i in range(numGaussians):
        z += gaussian2d(x, y, amp[i], center_x[i], center_y[i], bx[i], by[i])
    
    # Return the result
    return z
                
# Fitting 2D guassian    
def gaussian2D_fit(labels, X, Y, Z, coefs, plot=False):
    """This funciton performs a 2D gaussian fit on a mask of the subset of
        the image data

    Args:
        labels[ndarray of dtype int]: Labeled array, where all connected regions are assigned the same integer value.
            From the skimage morphology library
            
        X[numpy ndarry]: Meshgrid of X values from image dataset.
        Y[numpy ndarry]: Meshgrid of Y values from image dataset.
        Z[numpy ndarry]: Grid of X and Y values from image dataset, made when data is imported.
        coefs[numpy array]: Array to append the coefficient values

    Returns:
        The coeffcients of a 2D gaussion fit as a 1D array [a, bx, by, cx, cy] 

    """
    
    # define 2D Gaussian model, from the lmfit library
    model = lmfit.models.Gaussian2dModel()
    
    #Iterate over over the labes from 1 to the max number + 1
    label_max = np.amax(labels)
    
    fitted = []
    for i in range(1,label_max + 1):
        # our selection
        sel = (label_max == i) # Boolean when label_max is equal to i
        
        # zsel becomes a n-D array of shape z of 0's; where zsel of true gets where Z is not 0
        zsel = np.zeros(Z.shape); zsel[sel] = Z[sel]
        

        # The lmfit params; X and y values must be flattened to function
        params = model.guess(zsel.flatten(), X.flatten(), Y.flatten())

        # store the result of fitting 
        result = model.fit(zsel, x=X, y=Y, params=params)

        # save the coefficient values as a dict
        values = result.best_values

        # Retrive the values from the dict 
        bx = values.get('sigmax')
        by = values.get('sigmay')
        cx = values.get('centerx')
        cy = values.get('centery')
        a = values.get('amplitude') / (bx*by*2*math.pi)
        
        if plot:
            print([a, bx, by, cx, cy])
            tri_plot(X, Y, Z, "CCD Data")
            tri_plot(X, Y, gaussian2d(X, Y, a, cx, cy, bx, by), "2D gaussian")
        
        # append to coefficients
        fitted.append([a, bx, by, cx, cy])
        
    coefs.append(fitted)

######## END GAUSSIAN FUNCTIONS #########




###### 3 HANDLING IMAGE DATA LOADING #########

# Return the names of the .tiff files
def get_img_files(folder_name):
    """Description

    Args:
        folder_name[string]: The name of the folder containing the img files

    Returns:
        Returns a list of the file names as strings inside of the specifed folder
        that are .tiff files

    """
    
    # Assign path of the folder name to the files
    files = os.listdir(folder_name + "/")
    
    # Array to hold the names of the .tiff files
    tiff_files = []
    
    # Loop over ever file in the folder
    for file in files:
        # If the file ends in .tiff save it
        if file[-5:] == ".tiff":
            tiff_files.append(file)
    
    # Sort our files from least to greatest and save them
        # Assumes the files will be labeled numerically (008.tiff, 001.tiff, 003.tiff etc)
    files = np.sort(tiff_files)
    return files

###### END HANDLING IMAGE DATA LOADING #########





###### 4 PEAK DETECTION AND BLURRING ####

# Function to get and store the parameters of peaks, used with sum_2dgaussians
def get_peak_param(z_grid, bx, by):
    """  Returns the values of blur_and_detect_peaks in a 1D array in the format: [a, cx, cy, bx, by ]

    Args:    
        z_peaks[numpy ndarray]: A 2D array that is the output of blur_and_detect_peaks
        bx[float]: The sigma x, usually passed in hard coded at 0.01 
        by[float]: The sigma x, usually passed in hard coded at 0.01
    Returns:
        Array of the peak paramters in the format [a, cx, cy, bx, by] 

    """
    # Saves the values of the peaks in a 1D array in the format
    # a, cx, cy, bx, by
    
    # Get the dimensions of the image; used to create the x and y values
    dimensions = z_grid.shape 

    # With the length of the second dimension, create - 1 ~ 1 with dimensions[1] value 
    # (what add_coord was doing, but better)
    x = np.linspace(-1, 1, dimensions[1])

    # With the length of the first dimension, create - 1 ~ 1 with dimensions[0] value
    # (what add_coord was doing, but better)
    y = np.linspace(1, -1, dimensions[0])

    # create meshgrid as before
    x_grid, y_grid = np.meshgrid(x, y) 
    
    # Parameters
    sigma = 2 # For gaussian blur
    connectivity = 2 # for detect peaks connectivity

    # threshold for Z values; found in blur_and_detect_peaks
    threshold = np.max(z_grid) * 0.1 
    
    # Get the peak data after blurring 
    z_peaks = blur_and_detect_peaks(z_grid, sigma, threshold, connectivity)
    
    # Array to save the paramters
    peak_param = []
    
    #Loop over all the peaks found
    for i in range(len(z_peaks)):
        for j in range(len(z_peaks)):
            # If location i j is True
            if z_peaks[i][j]:
                # Store the values
                peak_param.append(z_grid[i][j])
                peak_param.append(x_grid[i][j])
                peak_param.append(y_grid[i][j])
                peak_param.append(bx)
                peak_param.append(by)
                
    # Return our peaks            
    return np.array(peak_param)

# Detect peaks after blurring
def blur_and_detect_peaks(z_grid, sigma, threshold, connectivity):
    
    """ Gets the peaks detected after applying Gaussian blurring and detect peaks algorithms.

    Args:    
        zgrid[numpy arry]: Numpy array generated from img file. Array of floats
        sigma[float]: Number passed to the gaussian filter. Number of gaussians applied.
        threshold[float]: Threshold value for z_grid 

    Returns:
        2D Array of Bool values

    """

     # Threshold - When put before the gaussian blur, removes edge peaks
    z_grid[z_grid<threshold] = 0

    # Gaussian blurring, 
    z_peaks = gaussian_filter(z_grid, sigma) # sigma = 3 so far best with detect connection at 2 or 3


    # Using Detect Peaks on subections before blurring
        # Detect peaks has been altered to accept a second argument. The second argument is the
        # Connectivity of generate_binary_structure
    z_peaks = detect_peaks(z_peaks, connectivity)
    
    return z_peaks

# Detects peaks that are likely the highest and seperate; works with gaussian blur to isolate
def detect_peaks(image, connectivity):
    """
        Takes an image and detect the peaks usingthe local maximum filter.
        Returns a boolean mask of the peaks (i.e. 1 when
        the pixel's value is the neighborhood maximum, 0 otherwise)
        
    Args:    
        image[numpy arry]: Numpy array generated from img file. Array of floats
        connectivity[int]: The connectivity for the neighborhood generated. 2 gets an 8-connected neighborhood

    Returns:
        2D Array of Bool values
    """

    # define an n-connected neighborhood( 8 connected when connecttivity equals 2)
        # first argument is the dimensions of array, second is the connectivity
        # range from 1 (no diagonal elements are neighbors) to rank (all elements are neighbors)
    neighborhood = generate_binary_structure(2,connectivity) 

    #apply the local maximum filter; all pixel of maximal value 
    #in their neighborhood are set to 1
    local_max = maximum_filter(image, footprint=neighborhood)==image
    #local_max is a mask that contains the peaks we are 
    #looking for, but also the background.
    #In order to isolate the peaks we must remove the background from the mask.

    #we create the mask of the background
    background = (image==0)

    #a little technicality: we must erode the background in order to 
    #successfully subtract it form local_max, otherwise a line will 
    #appear along the background border (artifact of the local maximum filter)
    eroded_background = binary_erosion(background, structure=neighborhood, border_value=1)

    #we obtain the final mask, containing only peaks, 
    #by removing the background from the local_max mask (xor operation)
    detected_peaks = local_max ^ eroded_background

    return detected_peaks


# Seperate the differnt subsections of an image
def peaks_subsections(z_grid, selection, z_peaks, peaks_arr, plot=False):    
    """
        Takes the z_grid, selection and result of blur_and_detect_peaks (z_peaks) and divides the image into 6
        subsections, getting the number of peaks from each one.

    Args:    
        z_grid[numpy arry]: Numpy array generated from img file. Array of floats
        selection[2D array]: Array of selection of areas to slice
        z_peaks[numpr array]: 2D array of Bools after Gaussian bluring and peak detection
        peaks_arr[empty array]: Array to store the values of peaks from the subsections
        plot[Bool]: If true, plots results of sebsection mask. Defaults to False

    Returns:
        Appends values of peaks to array Peaks
    """

    # Get the dimensions of the image; used to create the x and y values
    dimensions = z_grid.shape 

    # With the length of the second dimension, create - 1 ~ 1 with dimensions[1] value 
    # (what add_coord was doing, but better)
    x = np.linspace(-1, 1, dimensions[1])

    # With the length of the first dimension, create - 1 ~ 1 with dimensions[0] value
    # (what add_coord was doing, but better)
    y = np.linspace(1, -1, dimensions[0])

    # create meshgrid as before
    x_grid, y_grid = np.meshgrid(x, y) 


    # iterate over windows
    for j in range(6):
        # Define window
        xmin = selection[j][0]
        xmax = selection[j][1]
        ymin = selection[j][2]
        ymax = selection[j][3]

        # Define offsets
        #xctr = (xmin + xmax) / 2
        #yctr = (ymin + ymax) / 2

        # Define subsections
            # np.nonzero gives the values that arent zero; we are now getting the indices
            # as it is a 2D array, we select the first value(0)
        mask_x = np.nonzero(np.logical_and(x >= xmin, x <= xmax))[0]
        mask_y = np.nonzero(np.logical_and(y >= ymin, y <= ymax))[0]



        # Apply mask to subsections
            # from the minimum of mask y, to the max of max y, and the same for mask x
            # Returns the values at the indices as a 2D array
        # Added 15 before to zgrid values to see if that would put the images into proper frame
        X = x_grid[np.amin(mask_y):np.amax(mask_y), np.amin(mask_x):np.amax(mask_x)]
        Y = y_grid[np.amin(mask_y):np.amax(mask_y), np.amin(mask_x):np.amax(mask_x)]

        
        # get the bools of the peaks
        Z = z_peaks[np.amin(mask_y):np.amax(mask_y), np.amin(mask_x):np.amax(mask_x)]
        
        # Get the z_grid subsection
        Z_loc = z_grid[np.amin(mask_y):np.amax(mask_y), np.amin(mask_x):np.amax(mask_x)]
        #Z = z_grid[np.amin(mask_y):np.amax(mask_y), np.amin(mask_x):np.amax(mask_x)]

        ##### END SEPERATING INTO SUBSECTIONS ########

        # getting value of peak and saving it
        peak = Z_loc[Z]
        peaks_arr.append(peak)

    #### PLOTING BEFORE AND AFTER #####
        # Seperate image subsection plots    
            # create figure
        if plot:
            fig = plt.figure(figsize=(10, 7))

            # setting values to rows and column variables
            rows = 1 
            columns = 1

            # Original image 
            # Adds a subplot at the position of the third argument
            fig.add_subplot(rows, columns, 1) 
            # showing image
            plt.title("Detected Peaks")
            plt.imshow(Z)

            print('Number of peaks detected for subsection ' + str(j))
            print(len(peak))

    
######## END PEAK DETECTION #######





####### 5 CALIBRATION FUNCTIONS #######

#Function to get and store the parameters of peaks
def get_2D_list(z_grid, x_grid, y_grid):
    """
        Takes the image data after applying gaussian blur

    Args:    
        z_grid[numpy 2D arry]: Numpy array generated after passing it through gaussian blur
        x_grid[numpy 2D arry]: Grid generated from np.linspace in the shape of the img data grid(z_grid)
        y_grid[numpy 2D arry]: Grid generated from np.linspace in the shape of the img data grid(z_grid)
    Returns:
        numpy 2D array in the form of [a, x, y] where a is the intensity of the detected peak
    """
    # Saves the values of the peaks in a 2D array in the format
    # a, cx, cy
    peak_param = []
    for i in range(len(z_grid)):
        for j in range(len(z_grid)):
            # If location i j is True
            if z_grid[i][j]:
                peak_param.append([z_grid[i][j], x_grid[i][j], y_grid[i][j]])
    return np.array(peak_param)


# Find the strongest peak
def find_strongest_dude(peak_2D):
    """
        Takes the results of get_2D_list, finds the strongest a value (intensity) and returns its x and y location

    Args:    
        peak_2D[numpy 2D arry]: Numpy array generated from get_peak_2D

    Returns:
        tuple of the x and y values of hte strongest detected peak
    """
    strongest = 0
    for i in range(len(peak_2D)):
        if peak_2D[i][0] > strongest:
            strongest = peak_2D[i][0]
            # need to find the x and y location
            Cx = peak_2D[i][1]
            Cy = peak_2D[i][2]
    
    return[Cx, Cy]


    ##### THIS ONE MAY BE OFF ######
    # When the removal is set too low or high, it seems to be a bit funny
    ### Test later
#Remove peaks in our search area
def remv_near_peaks(z_peaks, rsearch):
    """
        Takes the results of get_2D_list and removes any particles within the rsearch threshold including itself

    Args:    
        z_peaks[numpy 2D arry]: Numpy array generated from get_2D_lists function
        rsearch[float]: The eucledian distance threshold that would be considered the "same" particle

    Returns:
        numpy 2D array of the particles after removing the nearest to the strongest dude
    """
    
    # The x and y values of the strongest peaks
    Cx, Cy = find_strongest_dude(z_peaks)
    
    
    # Iterate over the length of the peaks
    # here we use the get_peak_2D function which returns the detected peaks
    # in a 2D array of [a, x, y]
    for i in range(len(z_peaks)):
        
        # Coordinates of peak point
        Qx = z_peaks[i][1]
        Qy = z_peaks[i][2]

        # diatance between strongest peak and the rest of the peaks
        dist = math.dist([Cx, Cy], [Qx, Qy])

        # If in range, make the z_peaks value 0, include strongest yet found
        if dist < rsearch: #and [Qx, Qy] != [Cx, Cy]:
            z_peaks[i][0] = 0
       
    return z_peaks

# Get the offsets
def get_offsets(z_grid_blur):
    
    """
        Takes the z_grid data of the image (blurred as per instructions) of the Calibrations
        folder and returns the offsets. NOTE - The file MUST BE the calibrated image folder
        in order to get the proper offsets

    Args:    
        z_grid_blur[numpy 2D arry]: The image data(as a numpy 2D array) 
        from the Calibrations folder
        
    Returns:
        A dict of the calibrations in the form {"Segment(num):" [offset x, offset y]}, where(num)
        is the Segment number that corresponds to where the strongest peak was found
    """
    
    
    # New selection of each segment
    new_selection = [ [-0.837, -0.279, 0.000, 0.558],
                      [-0.279, 0.279, 0.000, 0.558],
                      [0.279, 0.837, 0.000, 0.558],
                      [0.279, 0.837, -0.558, 0.000],
                      [-0.279, 0.279, -0.558, 0.000],
                      [-0.837, -0.279, -0.558, 0.000] ]
    
    # Initilize dict to store values
    calib_dict = {}
    
    # The centers as defiend by the pdf
    centers = [ [-0.558, 0.279],
                [0.000, 0.279],
                [0.558, 0.279],
                [0.559, -0.279],
                [0.000, -0.279],
                [-0.559, -0.279] ]
    
    
    # Get the dimensions of the image; used to create the x and y values
    dimensions = z_grid_blur.shape 

    # With the length of the second dimension, create - 1 ~ 1 with dimensions[1] value 
    x = np.linspace(-1, 1, dimensions[1])

    # With the length of the first dimension, create - 1 ~ 1 with dimensions[0] value
    y = np.linspace(1, -1, dimensions[0])


    # create meshgrid as before
    x_grid, y_grid = np.meshgrid(x, y) 

    # storet the "peaks" in [a, x, y] form after blurring
    z_peaks = get_2D_list(z_grid_blur, x_grid, y_grid)
    #get_2D_list(z_grid_blur, x_grid, y_grid)
    
    
    # loop over the number of segments
    for i in range(6):
        # Store the x and y values of strongest peak
        Cx, Cy = find_strongest_dude(z_peaks)
        #loop over the defined centers of each segment
        for j in range(len(centers)):
            # Store the min and max values for x and y
            xmin = new_selection[j][0]
            xmax = new_selection[j][1]
            ymin = new_selection[j][2]
            ymax = new_selection[j][3]

            # Check which segment the strongest guy belongs to
            if Cx > xmin and Cx < xmax and Cy > ymin and Cy < ymax:
                # Store the offsets
                offsetX = Cx - centers[j][0] 
                offsetY = Cy - centers[j][1] 
                
                # Just in case/debugging
#                 offsetX = centers[j][0] - Cx
#                 offsetY = centers[j][1] - Cy
                
                # Save the offsets and the segment they are in
                calib_dict["Segment:" + str(j)] = [offsetX, offsetY]
                
        # Remove the strongest and everthing within  of him
        #### rmv_near peaks must be 0.25!!
        z_peaks = remv_near_peaks(z_peaks, 0.25)
            
    return calib_dict


# Get an array of calibration dicts; 1 for each segement
def get_Calibs(file_name):
       
    """
        Takes the file name of the Calibrations folder and returns an array of Calib dicts. Each
        index of that array corresponds the segment the strongest peak was found. Example:
        we need the offsets for when the strongest peak in the image is found in Segment 0,
        then we would need Calib[0] and from there we access the offset based on the segment we are
        searching in the current file.

    Args:    
        file_name[string]: The file that contains ONLY the 6 calibration images
        
    Returns:
        A 1D array of Calibration dicts
    """
    
    
    
    # Parameters for blurring
    sigma = 2 # For gaussian blur
    connectivity = 2 # for detect peaks connectivity
    
    # array to store Calib dicts
    Calib = []
    
    # Make a new loop, looping through all 6 calibration files
    files = get_img_files(file_name)
    for file in files:
        
        # get the image
        img = Image.open(file_name + '/' + file)
        # get the z data
        z_grid = np.array(img).astype('float')

        # blur the peaks
        z_grid_blur = gaussian_filter(z_grid, sigma)
        
        # append dict to Calib
        Calib.append(get_offsets(z_grid_blur))
        
    return Calib


# Get relative position of 2 segments
def get_relative_pos(brightest_seg, current_seg):
    
    """
        Takes the integer value of the brightest segment detected in the image and the current segment
        being searched, and returns what the relative x and y positions would be based on the center.
        Example: if we are in Segment 0 the center is (-0.558, 0.279), therefore the relative same position
        in Segment 1 would be the center of that segment (0.000, 0.279).
        
    Args:    
       brightest_seg[int]: Int value representing where the birghtest peak was found
        current_seg[int]: The current segment we are searching through
        
    Returns:
        The relatively same position of the two points
    """
    
    # centers of image
    centers = [ [-0.558, 0.279],
                    [0.000, 0.279],
                    [0.558, 0.279],
                    [0.559, -0.279],
                    [0.000, -0.279],
                    [-0.559, -0.279] ]

    # needs to know what the current checking segment is
    # and what segment the brightest peak came from
    relative_x = centers[current_seg][0] - centers[brightest_seg][0] 
    relative_y = centers[current_seg][1] - centers[brightest_seg][1] 
    
    return relative_x, relative_y


# Find the segment we are currently in
def find_segment(X, Y):
    """
        Takes the X and Y values (NOT index) of the image data (either x_grid/y_grid, strongest peak etc)
        and returns which segment that value is in.
        
        NOTE - needs to be modified in cases where the incoming values are outside of the selection

    Args:    
        X, Y[float]: The x and y coordinate values ( betwenn -1 ~ 1 usually)
        
    Returns:
        An integer value representing the segment located
    """
    
    
    # Borders of image data
    new_selection = [ [-0.837, -0.279, 0.000, 0.558],
                      [-0.279, 0.279, 0.000, 0.558],
                      [0.279, 0.837, 0.000, 0.558],
                      [0.279, 0.837, -0.558, 0.000],
                      [-0.279, 0.279, -0.558, 0.000],
                      [-0.837, -0.279, -0.558, 0.000] ]

    
    # iterate over the selections
    for i in range(len(new_selection)):
        xmin = new_selection[i][0]
        xmax = new_selection[i][1]
        ymin = new_selection[i][2]
        ymax = new_selection[i][3]

        # If the x and y coordinate fall within the range, return the segment location
        if X > xmin and X < xmax and Y > ymin and Y < ymax:
            return(i)
        

        
        ##### NOT NEEDED IN MAIN CODE YET; KEPT AS REFERENCE FOR FUTURE PROJECTS ######## 
        
# Find peaks/particles that are within a certain search radius 
    # Works to find peaks that are in different segments, but the same particle
def psearch(peaks, radius):
    
    """
        Takes the peaks values as a 2D numpy array, and a radius, and searches for any values
        within that radius and returns another array with the found particles
        
    Args:    
        peaks[numpy 2D array]: Array of arrays representing the peaks in the form of [intensity, x, y]
        radius[float]: The radius to search
        
    Returns:
        A 2D array of the peaks that were within the specifed radius
    """
    
    # The segment of the brightest particle found
    brightest_seg = Calibp[0]
    
    # Empty array to hold found peaks
    z_particles = []
    
    # loop over every peak
    for peak in peaks:
        
        # Define segment the x and y of the current peak
        segment = find_segment(peak[1], peak[2])
       
        
        # Get the offsets based on the segment where we found the brightes particle
        # And the current segment in peaks we are looking at
        offsetX = Calib[brightest_seg]["Segment:"+str(segment)][0]
        offsetY = Calib[brightest_seg]["Segment:"+str(segment)][1]

       
        # The relative x and y positions, based on where the strongest particle
        # was detected and add the offsets
        rel_x, rel_y = get_relative_pos(brightest_seg, segment)

        # Apply the strongest x and y positions
        rel_x = rel_x + StrongX + offsetX
        rel_y = rel_y + StrongY + offsetY

        # The distance between the current particle and the relative distance
        # based on the offets
        dist = math.dist([rel_x, rel_y],[peak[1], peak[2]])

        # If the distance is less than radius, 
        # The particle is likely same as brightest, but mirrored in a different segment
        # so add to particles
        if dist < radius:
            z_particles.append(peak)
            
    return z_particles


   ##### NOT NEEDED IN MAIN CODE YET; KEPT AS REFERENCE FOR FUTURE PROJECTS ########
    
# Returns array of peaks that have the detected values removed
def psearch_remv(peaks, radius):
    
    """
        Takes the peaks values as a 2D numpy array, and a radius, and searches for any values
        within that radius and returns another array with the found particles
        
    Args:    
        peaks[numpy 2D array]: Array of arrays representing the peaks in the form of [intensity, x, y]
        radius[float]: The radius to search
        
    Returns:
        A 2D array of the peaks that were within the specifed radius
    """

    # The segment of the brightest particle found
    brightest_seg = Calibp[0]

    # Empty array to hold found peaks
    keep = np.ones(np.shape(peaks), dtype=bool)
    # loop over every peak

    for i in range(len(peaks)):

        # Define segment the x and y of the current peak
        segment = find_segment(peaks[i][1], peaks[i][2])

        # Get the offsets based on the segment where we found the brightes particle
        # And the current segment in peaks we are looking at
        offsetX = Calib[brightest_seg]["Segment:"+str(segment)][0]
        offsetY = Calib[brightest_seg]["Segment:"+str(segment)][1]


        # The relative x and y positions, based on where the strongest particle
        # was detected and add the offsets
        rel_x, rel_y = get_relative_pos(brightest_seg, segment)

        # Apply the strongest x and y positions
        rel_x = rel_x + StrongX + offsetX
        rel_y = rel_y + StrongY + offsetY

        # The distance between the current particle and the relative distance
        # based on the offets
        dist = math.dist([rel_x, rel_y],[peaks[i][1], peaks[i][2]])

        # If the distance is less than radius, 
        # The particle is likely same as brightest, but mirrored in a different segment
        # so add to particles
        if dist < radius:
            keep[i] = False
  
    # Apply mask
    peaks = np.array(peaks)
    peaks = peaks[keep]

    # Get the proper shape of the array
    # We know it is in the form of [a, x, y] hence the '3'
    shape = int(len(peaks) / 3)

    #Reshape the array to keep with our [a, x, y] format
    peaks = np.reshape(peaks,(shape,3))

    return peaks


##### USED TO VISUALIZE SEARCH AREA AND RADIUS OF psearch_grid, NOT NEEDED FOR MAIN PROGRAM ######## 

# Draw the radius and location of area we are searching for peaks that belong to the same particle
def draw_radius(peaks, radius):
    
    """
        Takes the z_grid (blurred or otherwise) of image data and draws the radius it would search
        by increasing the intensity value in that area. Useful for graphing results and checking
        psearch is working.
        Follows same basic pattern as psearch
        
    Args:    
        peaks[numpy 2D array]: z_grid data of image
        radius[float]: The radius to search
        
    Returns:
        Peaks after altering
    """
    
    # define brightest_seg for cal
    brightest_seg = Calibp[0]
    
    # loop over every peak
    for i in range(len(peaks)):
        for j in range(len(peaks)):
            # find the segment
            segment = ccd_helpers.find_segment(x_grid[i][j], y_grid[i][j])
            if segment != None:
            
                #get the offsets
                offsetX = Calib[brightest_seg]["Segment:"+str(segment)][0]
                offsetY = Calib[brightest_seg]["Segment:"+str(segment)][1]
    

                # relative points
                rel_x, rel_y = get_relative_pos(brightest_seg, segment)
            
                
                # Apply the strongest x and y positions
                rel_x = rel_x + StrongX + offsetX
                rel_y = rel_y + StrongY + offsetY
                

                # The distance between the current particle and the relative distance
                # based on the offets
                dist = math.dist([rel_x, rel_y],[x_grid[i][j], y_grid[i][j]])
                
                
                if dist < radius: #and peaks[i][j] != 0:
                    peaks[i][j] = 65000.00 # Chosen arbitralily to make the area brighter than the rest
                
    return peaks        
    
####### END CALIBRATION FUNCTIONS #######